///|
test "black-box test - using factory function and validation" {
  assert_eq(1 + 1, 2)
  assert_eq(2 + 2, 4)
  inspect([1, 2, 3], content="[1, 2, 3]")

  // ä½¿ç”¨å·¥å‚å‡½æ•°åˆ›å»º Location
  let l = @lexer.Location::new(from=0, to=1)
  // ä½¿ç”¨è®¿é—®å™¨æ–¹æ³•è·å–ä½ç½®ä¿¡æ¯
  assert_eq(@lexer.Location::from(l), 0)
  assert_eq(@lexer.Location::to(l), 1)
  // ä»ç„¶å¯ä»¥æ˜¾ç¤º Location
  inspect(Show::to_string(l), content="{from: 0, to: 1}")

  // æµ‹è¯•éªŒè¯é€»è¾‘
  inspect(
    try? @lexer.Location::new(from=2, to=1),
    content="Err(Failure(\"Invalid location: start position cannot be greater than end position\"))",
  )
}


///|
test "Token::new_empty constructor" {
  let empty_token = @lexer.Token::new_empty()
  inspect(
    Show::to_string(empty_token),
    content="{location: {from: 0, to: 0}, kind: EOF, value: \"\"}",
  )
}

///|
test "Lexer::next" {
  // Test normal character reading
  let lexer = Lexer::new(source="aÎ±ä¸­ğŸŒÃ©_â¤ï¸A")
  inspect(lexer.next_char().unwrap(), content="a")
  inspect(lexer.current().pos(), content="1")
  inspect(lexer.current().index(), content="1")
  inspect(lexer.current().bytes(), content="1")
  inspect(lexer.eof(), content="false")

  inspect(lexer.next_char().unwrap(), content="Î±")
  inspect(lexer.current().pos(), content="2")
  inspect(lexer.current().index(), content="2")
  inspect(lexer.current().bytes(), content="3")
  inspect(lexer.eof(), content="false")

  inspect(lexer.next_char().unwrap(), content="ä¸­")
  inspect(lexer.current().pos(), content="3")
  inspect(lexer.current().index(), content="3")
  inspect(lexer.current().bytes(), content="6")
  inspect(lexer.eof(), content="false")

  inspect(lexer.next_char().unwrap(), content="ğŸŒ")
  inspect(lexer.current().pos(), content="4")
  inspect(lexer.current().index(), content="5")
  inspect(lexer.current().bytes(), content="10")
  inspect(lexer.eof(), content="false")

  inspect(lexer.next_char().unwrap(), content="Ã©")
  inspect(lexer.current().pos(), content="5")
  inspect(lexer.current().index(), content="6")
  inspect(lexer.current().bytes(), content="12")
  inspect(lexer.eof(), content="false")

  inspect(lexer.next_char().unwrap(), content="_")
  inspect(lexer.current().pos(), content="6")
  inspect(lexer.current().index(), content="7")
  inspect(lexer.current().bytes(), content="13")  
  inspect(lexer.eof(), content="false")

  // â€œâ¤ï¸â€æ˜¯ç”±ä¸¤ä¸ªç ç‚¹ç»„æˆçš„ç»„åˆå­—ç¬¦ï¼ˆâ¤ + ï¸ï¼‰ï¼ŒæŒ‰ç ç‚¹åˆ†åˆ«è¯»å–
  inspect(lexer.next_char().unwrap(), content="â¤")
  inspect(lexer.current().pos(), content="7")
  inspect(lexer.current().index(), content="9")
  inspect(lexer.current().bytes(), content="16")  
  inspect(lexer.eof(), content="false")
  ignore(lexer.next_char())
  //inspect(lexer.next().unwrap(), content=" ")
  inspect(lexer.current().pos(), content="8")
  inspect(lexer.current().index(), content="10")
  inspect(lexer.current().bytes(), content="17")  
  inspect(lexer.eof(), content="true")
}

///|
test "Lexer::next/eof" {
  // Test EOF behavior when reading beyond string length
  let lexer = Lexer::new(source=" ")
  inspect(lexer.next_char().unwrap(), content=" ")

  // Now reading beyond should set EOF and return null character
  inspect(lexer.next_char().is_empty(), content="true")
  inspect(lexer.eof(), content="true")
}

///|
test "Lexer::next/empty_source" {
  // Test behavior with empty source string
  let lexer = Lexer::new(source="")

  // First read should immediately set EOF and return null character
  inspect(lexer.next_char().is_empty(), content="true")
  println(lexer.current())
  inspect(lexer.eof(), content="true")
}

test "Lexer::backup" {
  // Test backup behavior
  let lexer = Lexer::new(source="ağŸŒÎ±â¤ï¸")
  ignore(lexer.next_char()) // Consume 'a'
  ignore(lexer.next_char()) // Consume 'ğŸŒ'
  ignore(lexer.next_char()) // Consume 'Î±'
  ignore(lexer.next_char()) // Consume 'â¤ï¸'
  lexer.rewind_back()
  inspect(lexer.current(), content="{pos: 3, index: 4, bytes: 7}")
  lexer.rewind_back()
  inspect(lexer.current(), content="{pos: 2, index: 3, bytes: 5}")
  lexer.rewind_back()
  inspect(lexer.current(), content="{pos: 1, index: 1, bytes: 1}")
  lexer.rewind_back()
  inspect(lexer.current(), content="{pos: 0, index: 0, bytes: 0}")
}


///|
test "Lexer::get_word" {
  let lexer = Lexer::new(source="ağŸŒÎ±â¤ï¸hello world ğŸ¤£A")
  
 // ç§»åŠ¨åˆ° 'ğŸŒ' ä¹‹åï¼Œå¹¶è®¾ç½®åˆ‡ç‰‡èµ·ç‚¹
  ignore(lexer.next_char()) // 'a'
  ignore(lexer.next_char()) // 'ğŸŒ'
  inspect(lexer.get_slice(), content="ağŸŒ")
  lexer.commit()

  // è¯»å– 'Î±'ï¼Œæ­¤æ—¶åˆ‡ç‰‡åº”ä¸º "Î±"
  ignore(lexer.next_char()) // 'Î±'
  let t1 = lexer.get_slice()
  inspect(t1, content="Î±")

  // è¯»å–â€œâ¤ï¸â€çš„ç¬¬ä¸€ä¸ªç ç‚¹ 'â¤'ï¼Œåˆ‡ç‰‡è§†å›¾åº”æ‰©å±•ä¸º "Î±â¤"
  ignore(lexer.next_char()) // 'â¤'
  //ignore(lexer.next())
  let t2 = lexer.get_slice()
  inspect(t2, content="Î±â¤ï¸")

  // è¯»å– "hello " å¹¶æ–­è¨€
  lexer.commit()
  ignore(lexer.next_char()) // 'h'
  ignore(lexer.next_char()) // 'e'
  ignore(lexer.next_char()) // 'l'
  ignore(lexer.next_char()) // 'l'
  ignore(lexer.next_char()) // 'o'
  println(lexer.get_slice())
  inspect(lexer.get_slice(), content="hello")

  // è¯»å– "world ğŸ¤£ " å¹¶æ–­è¨€
  lexer.commit()
  ignore(lexer.next_char()) // ' '
  ignore(lexer.next_char()) // 'w'
  ignore(lexer.next_char()) // 'o'
  ignore(lexer.next_char()) // 'r'
  ignore(lexer.next_char()) // 'l'
  ignore(lexer.next_char()) // 'd'
  ignore(lexer.next_char()) // ' '
  ignore(lexer.next_char()) // 'ğŸ¤£'
  ignore(lexer.next_char()) // ' '
  println(lexer.current())
  println(lexer.current())
  inspect(lexer.get_slice(), content=" world ğŸ¤£A")
}

test "Lexer::peek_current" {
  let lexer = Lexer::new(source="ağŸŒÎ±â¤ï¸hello world ğŸ¤£A")
  inspect(lexer.peek_current(), content="a")
  inspect(lexer.current(), content="{pos: 0, index: 0, bytes: 0}")
  ignore(lexer.next_char())
  inspect(lexer.peek_current(), content="ğŸŒ")
  inspect("{pos: \{lexer.current().pos}, index: \{lexer.current().index}}", content="{pos: 1, index: 1}")
  ignore(lexer.next_char())
  inspect(lexer.peek_current(), content="Î±")
  inspect("{pos: \{lexer.current().pos}, index: \{lexer.current().index}}", content="{pos: 2, index: 3}")
}

test "Lexer::find_next_position" {
  let lexer = Lexer::new(source="ağŸŒÎ±â¤ï¸hello world ğŸ¤£A")
  inspect(lexer.find_next_position(lexer.current()), content="{pos: 1, index: 1, bytes: 0}")
  ignore(lexer.next_char())
  inspect(lexer.find_next_position(lexer.current()), content="{pos: 2, index: 3, bytes: 0}")
  ignore(lexer.next_char())
  inspect(lexer.find_next_position(lexer.current()), content="{pos: 3, index: 4, bytes: 0}")
  ignore(lexer.next_char())
  inspect(lexer.find_next_position(lexer.current()), content="{pos: 4, index: 6, bytes: 0}")
  ignore(lexer.next_char())
  inspect(lexer.find_next_position(lexer.current()), content="{pos: 5, index: 7, bytes: 0}")
}

